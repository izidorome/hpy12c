from decimal import Decimal
from math import log


def ipmt(rate, per, nper, pv, pfv=0, end_or_beginning=0):
    vpmt = pmt(rate, nper, pv, pfv, end_or_beginning)
    vfv = fv(rate, (per - 1), vpmt, pv, end_or_beginning) * rate
    temp = vfv / (1 + rate) if (end_or_beginning == 1) else vfv

    return 0.0 if (per == 1 and end_or_beginning == 1) else temp


def fv(rate, nper, pmt, pv, end_or_beginning=0):
    temp = (1 + rate) ** nper
    fact = (1 + rate * end_or_beginning) * (temp - 1) / rate

    return -(pv * temp + pmt * fact)


def pmt(rate, nper, pv, fv=0, end_or_beginning=0):
    temp = (1 + rate) ** nper
    fact = (1 + rate * end_or_beginning) * (temp - 1) / rate

    return -(fv + pv * temp) / fact


def nper(rate, pmt, pv, fv=0, end_or_beginning=0):
    if rate == 0:
        return (-pv - fv) / pmt

    z = pmt * (1 + rate * end_or_beginning) / rate
    temp = log((-fv + z) / (pv + z))

    return temp / log(1 + rate)


def pv(rate, nper, pmt, fv=0, end_or_beginning=0):
    temp = (1 + rate) ** nper
    fact = (1 + rate * end_or_beginning) * (temp - 1) / rate

    return -(fv + pmt * fact) / temp


def npv(discount, cashflows):
    total = 0
    for index, cashflow in enumerate(cashflows):
        print(index, cashflow, total)
        total += Decimal(cashflow) / (1 + Decimal(discount)) ** (index + 1)


    return float(total)


def rate(nper, pmt, pv, fv=0, end_or_beginning=0, rate_guess=0.10):
    guess = rate_guess
    tolerancy = 1e-6
    close = False

    while not close:
        temp = _newton_iter(
            guess, nper, float(pmt), float(pv), float(fv), end_or_beginning
        )
        next_guess = round(guess - temp, 20)
        diff = abs(next_guess - guess)
        close = diff < tolerancy
        guess = next_guess

    return next_guess


# This method was borrowed from the NumPy rate formula
# which was generated by Sage
#
def _newton_iter(r, n, p, x, y, w):
    t1 = (r + 1) ** n
    t2 = (r + 1) ** (n - 1)
    return (y + t1 * x + p * (t1 - 1) * (r * w + 1) / r) / (
        n * t2 * x
        - p * (t1 - 1) * (r * w + 1) / (r**2)
        + n * p * t2 * (r * w + 1) / r
        + p * (t1 - 1) * w / r
    )
